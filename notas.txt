- IMPORTANTE! o projeto maven que contém todos os modulos deve ser ser compilados com:
mvn clean:clean resources:resources compiler:compile jar:jar install:install -DskipTest:true
ou, no netbeans, clicando com o botao direito do rato sobre o projeto > maven > goals... >inserir 
na barra de texto o seguinte: clean:clean resources:resources compiler:compile jar:jar install:install -DskipTest:true

- o projeto precisa de ser executado num JDK de 32 bits e com os DLL's na pasta bin dentro do diretorio do JDK usado
- Os dll's da libraria em C++ sao colocados em C:\Program Files (x86)\Java\jdk1.8.0_144\bin (ou outro jdk de 32 bits)
-------------------------------Isto é um relatório ordenado do trabalho feito, os pontos em baixo indicam o que foi feito
mais recentemente ---------------------------------------------------------------

---->Instalar livraria McKenney
necessário primeiro instalar python 2.7 e pip: https://www.python.org/downloads/release/python-2716/
Documentaçao para instalar:
https://pypi.org/project/pyspatiotemporalgeom/
Download:
https://bitbucket.org/marmcke/pyspatiotemporalgeom/downloads/


- modulo jts-app contém a gui
- modulo test contem o test runner (um programa que permite carregar fihceiros .wkt e apresentar a geometria neles definida
- modulo example contém exemplos de código para criação de formas (polyline, polygon...) 
e operações com as mesmas (interseção,...)
- modulo app contem o testBuilder, uma gui mais completa que permite fazer operações com geometrias 2D
- no modulo app, package org.locationtech.jttest.testbuilder a classe JTSTstBuilder permite correr o testBuilder com a gui.
No entanto, a classe que carrega os icones a apresentar na gui verifica o diretório de resources no /modules/app/target/classes/,
no entanto sem o goal resources:resources estes não são copiados do diretório /modules/app/source/main/resources/ 
para o /modules/app/target/classes/
- projeto "app" package "render" contem a classe GeomtryPaint metodo paint, que pega num objeto Geometry e o desenha na gui
- projeto "app" package "ui.style" tem a classe basic style, que permite definir a cor da linha e do preenchimento da 
geometria e desenhá-la
- gesture finished.., classe rectangle tool
- JTSTestBuilderFrame, pode-se alterar lá o factor de zoom.
- Viewport: setOrigin é chamado sempre que se faz zoom, e pode ser a causa de a origem ficar desfasada

-JTSTestBuilderFrame: carrega os componentes da janela


Alterações
- Apresentada uma janela de escolha de ficheiros quando se corre o programa (usado para escolher uma imagem). Alteração 
feita no main da classe JTSTestBuilder do package "testbuilder", do modulo "app"
- GeometryEditPanel: colocada imagem como fundo de ecrã (metodo paintComponent e repaintComponent para atualizar em eventos)
- AppImage: classe que tem a imagem de fundo e métodos estaticos que permite manter o seu aspect ratio
- A imagem mantem agora o seu aspect ratio quando a janela é resized
- GridRenderer: atributo isEnabled colocado a false para nao apresentar grelha
- RenderManager: metodo erase, usado para atualizar o que é apresentado no edit panel. Agora é chamada a função "paintComponent"
do GeometryEditPanel, que redesenha a imagem por cima.
- adicionado botao que mostra/esconde a grid. classe JTSTestBuilderToolbar tem o botao btnShowHideGrid, com o evento de clique
"btnShowHideGrid_actionPerformed" na classe JTSTestBuilderFrame.

-adicionado classe PointUtils e CoordUtils, no projeto "core", package "geometry", com a transformada de pontos e coordenadas
 respetivamente...
- criada classe no projeto "core", package "io", chamada CorrReader, que faz o parsing dos ficheiros de .corr
para um array de Coordenate.
- no projeto "app", package "util.io", foi criada classe CorrToGeometries, que permite converter um polygon a partir de um
Coordinate[]. Caso o Coordinate[] não seja fechado (ultimas coordenadas iguais ás primeiras, existe um metodo que irá fechar
as coordenadas).
-  GeometryEditPanel, adicionado metodo drawGeometry, que recebe o conjunto de coordenadas de um ficheiro e
chama métodos para transformar as coordenadas da imagem original para o tamanho da janela, e desenhar o poligono, removendo
primeiro quaisquer desenhos que lá existam.
Este método é chamado no main da classe JTSTestBuilder e também no metodo componentResized sempre a janela muda
as suas dimensões.
- Agora a imagem é colocada nos pontos -x, e -y, correspondentes as coordenadas do painel do canto inferior esquerdo
(para corrigir desfasamentos de geometria e imagem)
- corrigido problema em que a geometria não era desenhada no sitio correto da imagem se a janela fosse maximizada
ou minimizada. O tamanho do painel de edição não é atualizado a tempo se usar os metodos viewport.getHeightInView
e viewport.getWidthInView. Agora é usado o metodo getSize dentro da classe GeometryEditPanel.
- na classe Viewport, metodo zoom, a escala muda, mas a origem mantém-se sempre 0,0 indepentemente do zoom. 
Assim a imagem e a geometria não ficam desalinhadas (solução encontrada para fazer o zoom ... poderá haver solução melhor...)
- classe AppImage, metodo keepAspectRatioAndDrawImage, a imagem é colocada no canto inferior esquerdo do painel
- classe GeometryEditPanel, metodo correctCoordinates, é adicionado a diferença entre a altura do painel e da imagem
á geometria de modo a bater certo com a alteração anterior.


--- Mudou-se a forma como a imagem é desenhada. Agora cria-se um segundo poligono, e idealmente, a imagem 
seria colocada como preenchimento desse poligono.
- o Poligono que representa o objeto está na geometria de indice 1. O retangulo que contem a imagem esta no indice 1.
- criada classe CostumBasicStyle (package ui.style) com o intuito de colocar a imagem no fundo do poligono desenhado.
- no geometry edit panel, feitas alterações para este novo método, incluindo uma função que cria os vertices do
poligono com o tamanho da imagem do painel
- package ui.render, classe GeometryPainter, criado metodo paintCostum que é igual ao paint, mas que desenha a imagem no fundo
do poligono! -> esta nova forma de desenhar a imagem resolve o problema do zoom
- o poligono que tem a imagem tem contorno e cor de preenchimento transparente.
- Foi trocada a ordem das camadas A e B. A tem a geometria, B tem a imagem. Queremos que B aparece atrás de A, isto é
que a geometria fica em cima da imagem

-Para criar 2 edit panels: foi, no JTSTBuilderFrame, criado 2 instancias do TestCasePanel, que contem o edit panel.
 A cada uma dessas instâncias foi passado uma instancia diferente do GeometryEditModel, que entre outros dados, contém a
informação das geometrias que são desenhadas no ecrã.
-Na package ui.tools, nas classes Rectangle tool e zoom tool e EditVertexTool, é considerado apenas o painel em que o rato
se encontra para fazer a ação respetiva.
- Para resolver certos problemas relacionado com desfasamento e remoçao de outras geometrias desenhadas em cima da imagem
ao mudar tamanho da janela, o método que le as coordenadas do ficheiro (drawGeometry, classe GeometryEditPanel)
 do ficheiro de correspondencias é chamado apenas 1 vez
- tooltips das coordenadas quando o cursor está em cima de um ponto: evento getToolTipText (GeometryEditPanel)
, e o texto é dado na função writeLocationString, classe GeometryLocationsWritter. O texto da tooltip foi alterado
de modo a indicar o numero do ponto e as suas coordenadas.
- criado classe AppCorrGeometries. Guarda a lista de coordenadas das 2 geometrias (1 de cada painel). Tem métodos
que lhe permitem ver se uma dada coordenada se encontra na geometria, ou devolver a coordenada da outra geometria que 
corresponde a uma coordenada da geometria. 
- A classe anterior permite também fazer higlight a vermelho no ponto correspondente da outra geometria. Ao colocar o rato
sobre um ponto da geometria, aparecerá no ponto correspondente a essa coordenada na outra geometria um ponto vermelho.

-JTSTestBuilderToolBar: contem o botao next e previous, entre outros

- Janela com a animaçao do morphing e graficos: iniciada em AppCorrGeometries, metodo #openMorphingGeometryFrame

---> todo:
 - eventual refactoring -> acaba aqui v0.2
 - versão 0.3:
	comunicar com libraria em C++ que, dado uma geometria no instante t e outra no instante t+x, retorna 
	a geometria prevista num instante entre t e t+x.
	apresentar essa geometria num painel (por agora, apresentar no painel da esquerda)
	Criar menu em baixo que permite definir o tempo no morphing da geometria. (talvez nao seja preciso)

	Nao existe ainda método que converte as coordenadas da geometria no painel para as coordenadas em pixeis do wkt,
	e assim, se houver qualquer ediçao em alguma das geometrias esta nao sera considerada para o morphing e apenas é
	considerado as coordenadas originais do ficheiro corr

	-guardar imagem -> caixa de indicaçao de estado de operaçao (sucesso, falha a guardar)..
	- guardar imagens como gif -> PROBLEMA: ficamos sem heap space...
	- saltar x imagens ao chamar GIF e ao guardar imagem a imagem ? (geometria n aparece ainda..)
	-aplicar translação as coordenadas da geometria resultante do morphing na janela morphingGeometryPanel

	-criar uma cache que guarda o diretorio das imagens e corrs que foram abertos anteriormente (para
	o utilizador nao tenha que selecionar estes ficheiros sempre que abre a aplicação
	- problema ao chamar quality measures
	- colocar legenda em cima dos paineis a indicar o nmr da imagem
	- desenhar a geometria morphed com uma cor diferente
	- problema na forma como se desenha as geometrias
	- Nao desenhar graficos de area quando temos mesh!

 - area e perimetro ao selecionar 

---------- secondo: --------
funções do morphing a chamar:
Algebras\ColumnMoving\Sources\MRegions.h # AtInstant (ver os parametros de input e como chamar)
inputs de tempo: temporal
inputs das geometrias: spatial.
------------------------------
- bugs:
	- show morphing geometry: se existir zoom a geometria nao fica corretamente alinhada na imagem
	- ao editar um vertice, a geometria desloca-se e deixa de estar alinhada com a imagem de fundo!
	-no 2º painel, por vezes o zoom deixa de funcionar
	-streampolygon e polygon desaparecem apos uma ação qualquer

